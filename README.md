project/ <br>
├── app.py                        # FastAPI app entry point<br>
├── main.py                       # Stremlit entry point for testing<br>
├── services/<br>
│   ├── conversation_manager.py    # Manages the flow of conversations<br>
│   ├── speech_service.py          # Handles Azure speech-to-text and text-to-speech interactions<br>
│   ├── groq_service.py            # Interacts with Groq's API for summarization and policy refinement<br>
│   ├── question_data.py           # Stores predefined questions for accidents and incidents<br>
├── models/
│   └── conversation.py            # Defines the Conversation class to manage conversation state<br>
├── conversations/                 # Directory where conversation JSON files are stored<br>
├── .env                           # Environment variables for API keys<br>
├── requirements.txt               # Project dependencies<br>
└── README.md                      # Project instructions and documentation<br>

Features of this Prototype :<br>
This is a Initial response agent to report for accident/incident in Care Home<br>

i. Grammartical correction for users response<br>
ii. Predefine standard Question will be asked<br>
iii. Summarization based on incident/accident sceneio<br>


Core Components<br>
1. app.py (FastAPI Setup)<br>
This is the entry point when running the application as a FastAPI web server. It exposes an endpoint /start_voice_conversation that begins the voice interaction in the background using the ConversationManager.

FastAPI endpoint: POST /start_voice_conversation<br>
    Starts a new conversation. <br>
    The conversation is processed in the background.<br>
    Returns a conversation ID that can be used to track or retrieve the conversation later.<br>

2. main.py (Command-line Entry Point)<br>
Used for testing and running the system directly from the command line. It starts the conversation using ConversationManager.<br>

3. services/conversation_manager.py <br>
Manages the flow of the conversation, handling state transitions, questions, and responses. It uses SpeechService to handle speech recognition and synthesis and GroqService to summarize the scenario and refine policies.

    create_new_conversation: Generates a new conversation object. <br>
    start_conversation: Starts the conversation by asking the user whether they want to report an incident or accident. 
    proceed_to_next_question: Moves through the list of questions, stores the responses, and handles the conversation logic.
    handle_confirmation_steps: Handles multi-step confirmation steps after the conversation (e.g., notifying the manager, updating a resident's risk profile).
    save_conversation_to_json: Saves the entire conversation to a JSON file.
    stop_conversation: Cleans up resources and ends the conversation.

4. services/speech_service.py <br>
Handles speech-to-text (recognizing user input) and text-to-speech (synthesizing chatbot responses) using Azure Speech SDK.

    synthesize_speech: Converts text into speech and plays it back to the user.
    recognize_speech: Captures user input from the microphone and returns the recognized text.
    stop_speech_recognition: Stops any ongoing speech recognition processes.<br>

5. services/groq_service.py<br>
Interacts with Groq's API to provide additional intelligence like summarizing the user's responses and refining policies.

    summarize_scenario: Summarizes the entire conversation into a brief report.
    refine_with_llm: Provides policy suggestions based on user responses.<br>

6. models/conversation.py <br>
The Conversation class is used to store the current state of the conversation, including the user’s responses, the scenario type, and the list of questions being asked.

    conversation_id: Unique identifier for the conversation.
    current_question_index: Keeps track of which question is currently being asked.
    responses: Stores user responses to the questions.
    scenario_type: Tracks whether the scenario is an accident or incident.
    questions: Holds the list of questions being asked during the conversation.
    scenario_summary: Holds the summary of the conversation generated by Groq.
    unanswered_questions: Tracks any questions that were not answered by the user.
    waiting_for_confirmation_step: Tracks which confirmation step the conversation is currently in.<br>

7. services/question_data.py<br>
Stores predefined questions for accidents and incidents, which are used by the ConversationManager to ask the user.

To Run this program.<br>
Commands<br>
pipenv install<br>
pipenv shell(make sure pipenv is active)<br>
pipenv run pip install -r requirements.txt <br>
**configure your .env file** <br>
streamlit run main.py <br>